{% extends 'base.html' %}
{% load static %}

{% block title %}WhatsApp Business - Comercial{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row mb-4">
        <div class="col">
            <nav aria-label="breadcrumb">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="{% url 'comercial:home' %}">Comercial</a></li>
                    <li class="breadcrumb-item active" aria-current="page">WhatsApp Business</li>
                </ol>
            </nav>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col d-flex justify-content-between align-items-center">
            <div>
                <h1 class="h2 mb-1">
                    <i class="fab fa-whatsapp me-2 text-success"></i>
                    WhatsApp Business
                </h1>
                <p class="text-muted mb-0">Gest√£o comercial das suas contas WhatsApp Business</p>
            </div>
            <span id="ws-status" class="badge bg-secondary fs-6">‚è≥ Conectando...</span>
        </div>
    </div>

    <!-- Estat√≠sticas -->
    <div class="row mb-4">
        <div class="col-md-4">
            <div class="card border-0 bg-warning bg-opacity-10">
                <div class="card-body text-center">
                    <div class="d-flex justify-content-center align-items-center mb-3">
                        <div class="bg-warning bg-opacity-20 p-3 rounded-circle">
                            <i class="fas fa-clock text-warning fa-2x"></i>
                        </div>
                    </div>
                    <h3 class="text-warning" id="pending-count">{{ total_pending }}</h3>
                    <small class="text-muted">Aguardando Atendimento</small>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card border-0 bg-primary bg-opacity-10">
                <div class="card-body text-center">
                    <div class="d-flex justify-content-center align-items-center mb-3">
                        <div class="bg-primary bg-opacity-20 p-3 rounded-circle">
                            <i class="fas fa-user text-primary fa-2x"></i>
                        </div>
                    </div>
                    <h3 class="text-primary">{{ my_conversations }}</h3>
                    <small class="text-muted">Minhas Conversas</small>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card border-0 bg-success bg-opacity-10">
                <div class="card-body text-center">
                    <div class="d-flex justify-content-center align-items-center mb-3">
                        <div class="bg-success bg-opacity-20 p-3 rounded-circle">
                            <i class="fab fa-whatsapp text-success fa-2x"></i>
                        </div>
                    </div>
                    <h3 class="text-success">{{ pending_conversations.count }}</h3>
                    <small class="text-muted">Contatos Dispon√≠veis</small>
                </div>
            </div>
        </div>
    </div>

    <!-- Conversas Aguardando Atendimento -->
    <div class="row mb-4">
        <div class="col">
            <h3 class="h5 mb-3">
                <i class="fas fa-headset me-2"></i>
                Conversas Aguardando Atendimento
                <span class="badge bg-info ms-2" id="refresh-indicator" style="display: none;">
                    <i class="fas fa-sync fa-spin"></i> Atualizando...
                </span>
            </h3>
            <!-- Container com auto-refresh via HTMX -->
            <div id="conversations-container"
                 hx-get="{% url 'comercial:conversations_table' %}"
                 hx-trigger="load, every 3s"
                 hx-indicator="#refresh-indicator">
                {% include 'comercial/whatsapp/partials/conversation_table.html' %}
            </div>
        </div>
    </div>


</div>

<!-- Script para atualizar contador ap√≥s refresh da tabela -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Atualiza contador quando a tabela for recarregada
    document.body.addEventListener('htmx:afterSwap', function(evt) {
        if (evt.detail.target.id === 'conversations-container') {
            // Conta quantas linhas tem na tabela
            const rows = evt.detail.target.querySelectorAll('tbody tr[data-conversation-id]');
            const count = rows.length;
            
            // Atualiza o contador
            const counterElement = document.getElementById('pending-count');
            if (counterElement) {
                const oldCount = parseInt(counterElement.textContent);
                counterElement.textContent = count;
                
                // Adiciona efeito visual se mudou
                if (oldCount !== count) {
                    counterElement.classList.add('text-white', 'bg-warning', 'rounded', 'px-2');
                    setTimeout(() => {
                        counterElement.classList.remove('text-white', 'bg-warning', 'rounded', 'px-2');
                    }, 1000);
                }
            }
            
            // Se n√£o tem conversas, mostra 0
            if (!rows.length) {
                const noConversations = evt.detail.target.querySelector('.fa-comments');
                if (noConversations && counterElement) {
                    counterElement.textContent = '0';
                }
            }
        }
    });
    
    // Som de notifica√ß√£o quando chegar nova conversa
    let lastCount = parseInt(document.getElementById('pending-count').textContent || '0');
    
    document.body.addEventListener('htmx:afterSwap', function(evt) {
        if (evt.detail.target.id === 'conversations-container') {
            const newCount = evt.detail.target.querySelectorAll('tbody tr[data-conversation-id]').length;
            
            // Se aumentou o n√∫mero de conversas, toca som
            if (newCount > lastCount) {
                // Cria elemento de √°udio tempor√°rio
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSl7y+/XiyMGHm7A7+OZURE');
                audio.volume = 0.5;
                audio.play().catch(e => console.log('Erro ao tocar som:', e));
                
                // Mostra notifica√ß√£o do navegador se permitido
                if (Notification.permission === 'granted') {
                    new Notification('Nova conversa WhatsApp!', {
                        body: 'Uma nova conversa est√° aguardando atendimento',
                        icon: '/static/favicon.png'
                    });
                }
            }
            
            lastCount = newCount;
        }
    });
    
    // Pede permiss√£o para notifica√ß√µes
    if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
    }
});
</script>

<!-- WebSocket para atualiza√ß√µes em tempo real -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Configura√ß√£o do WebSocket
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/comercial/whatsapp/`;
    
    let socket = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    
    function connectWebSocket() {
        try {
            console.log('üîó Tentando conectar WebSocket:', wsUrl);
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function(e) {
                console.log('üü¢ WebSocket conectado com sucesso');
                reconnectAttempts = 0;
                
                // Mostra indicador de conex√£o
                updateConnectionStatus(true);
            };
            
            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('üì® Mensagem recebida:', data);
                
                // Processa diferentes tipos de eventos
                switch(data.type) {
                    case 'conversation_new':
                        handleNewConversation(data.conversation);
                        break;
                    case 'conversation_assigned':
                        handleConversationAssigned(data.conversation);
                        break;
                    case 'conversation_updated':
                        handleConversationUpdated(data.conversation);
                        break;
                    case 'message_received':
                        handleMessageReceived(data.message, data.conversation_id);
                        break;
                }
            };
            
            socket.onclose = function(event) {
                console.log('üî¥ WebSocket desconectado. C√≥digo:', event.code, 'Motivo:', event.reason);
                updateConnectionStatus(false);
                
                // Mensagens espec√≠ficas por c√≥digo de erro
                let errorMessage = '';
                switch(event.code) {
                    case 4001:
                        errorMessage = 'Usu√°rio n√£o autenticado';
                        break;
                    case 4003:
                        errorMessage = 'Acesso negado - usu√°rio n√£o √© do grupo Comercial';
                        break;
                    case 1006:
                        errorMessage = 'Conex√£o perdida inesperadamente';
                        break;
                    default:
                        errorMessage = `Erro de conex√£o (${event.code})`;
                }
                
                console.log('‚ùå Motivo:', errorMessage);
                
                // Tentativa de reconex√£o apenas para erros recuper√°veis
                if (event.code === 1006 && reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    console.log(`‚è≥ Tentando reconectar... (${reconnectAttempts}/${maxReconnectAttempts})`);
                    setTimeout(connectWebSocket, 3000 * reconnectAttempts);
                } else if (event.code >= 4000) {
                    console.log('‚ùå Erro permanente, n√£o tentando reconectar');
                    showNotification('Erro de WebSocket: ' + errorMessage, 'error');
                } else if (reconnectAttempts >= maxReconnectAttempts) {
                    console.log('‚ùå M√°ximo de tentativas atingido - WebSocket em modo fallback');
                    showNotification('WebSocket desconectado - usando modo fallback', 'warning');
                }
            };
            
            socket.onerror = function(error) {
                console.error('‚ùå Erro no WebSocket:', error);
                updateConnectionStatus(false);
            };
            
        } catch (error) {
            console.error('‚ùå Erro ao conectar WebSocket:', error);
            updateConnectionStatus(false);
        }
    }
    
    function updateConnectionStatus(isConnected) {
        // Atualiza indicador visual da conex√£o (se existir)
        const statusIndicator = document.querySelector('#ws-status');
        if (statusIndicator) {
            if (isConnected) {
                statusIndicator.className = 'badge bg-success';
                statusIndicator.textContent = 'üü¢ Tempo Real';
            } else {
                statusIndicator.className = 'badge bg-danger';
                statusIndicator.textContent = 'üî¥ Desconectado';
            }
        }
    }
    
    function handleNewConversation(conversation) {
        // Atualiza contador de conversas aguardando
        const pendingCount = document.querySelector('[data-pending-count]');
        if (pendingCount) {
            const current = parseInt(pendingCount.textContent) || 0;
            pendingCount.textContent = current + 1;
        }
        
        // Recarrega a lista de conversas
        setTimeout(() => {
            window.location.reload();
        }, 1000);
        
        // Mostra notifica√ß√£o
        showNotification('Nova conversa aguardando atendimento!', 'success');
    }
    
    function handleConversationAssigned(conversation) {
        // Remove da lista se foi atribu√≠da a outro atendente
        const conversationRow = document.querySelector(`[data-conversation-id="${conversation.id}"]`);
        if (conversationRow) {
            conversationRow.style.transition = 'opacity 0.5s';
            conversationRow.style.opacity = '0.5';
            setTimeout(() => {
                conversationRow.remove();
                updateCounters();
            }, 500);
        }
    }
    
    function handleConversationUpdated(conversation) {
        // Atualiza informa√ß√µes da conversa na tela
        const conversationRow = document.querySelector(`[data-conversation-id="${conversation.id}"]`);
        if (conversationRow) {
            // Atualiza √∫ltima atividade, mensagens n√£o lidas, etc.
            window.location.reload();
        }
    }
    
    function handleMessageReceived(message, conversationId) {
        // Atualiza contador de mensagens da conversa
        const messageCount = document.querySelector(`[data-conversation-id="${conversationId}"] [data-message-count]`);
        if (messageCount) {
            const current = parseInt(messageCount.textContent) || 0;
            messageCount.textContent = current + 1;
        }
        
        // Destaca a conversa
        const conversationRow = document.querySelector(`[data-conversation-id="${conversationId}"]`);
        if (conversationRow) {
            conversationRow.classList.add('table-warning');
            setTimeout(() => {
                conversationRow.classList.remove('table-warning');
            }, 3000);
        }
        
        // Mostra notifica√ß√£o
        showNotification('Nova mensagem recebida!', 'info');
    }
    
    function updateCounters() {
        // Atualiza contadores baseado no que est√° vis√≠vel na tela
        const visibleRows = document.querySelectorAll('tbody tr[data-conversation-id]').length;
        const pendingCount = document.querySelector('[data-pending-count]');
        if (pendingCount) {
            pendingCount.textContent = visibleRows;
        }
    }
    
    function showNotification(message, type = 'info') {
        // Cria e mostra notifica√ß√£o toast
        let bgColor = 'primary';
        switch(type) {
            case 'success': bgColor = 'success'; break;
            case 'error': bgColor = 'danger'; break;
            case 'warning': bgColor = 'warning'; break;
            default: bgColor = 'primary';
        }
        
        const toastHtml = `
            <div class="toast align-items-center text-white bg-${bgColor} border-0" role="alert" aria-live="assertive" aria-atomic="true" data-bs-delay="4000">
                <div class="d-flex">
                    <div class="toast-body">
                        ${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                </div>
            </div>
        `;
        
        // Adiciona √† √°rea de toasts
        let toastContainer = document.querySelector('.toast-container');
        if (!toastContainer) {
            toastContainer = document.createElement('div');
            toastContainer.className = 'toast-container position-fixed top-0 end-0 p-3';
            document.body.appendChild(toastContainer);
        }
        
        toastContainer.insertAdjacentHTML('beforeend', toastHtml);
        
        // Ativa o toast
        const toastEl = toastContainer.lastElementChild;
        const toast = new bootstrap.Toast(toastEl);
        toast.show();
        
        // Remove ap√≥s fechar
        toastEl.addEventListener('hidden.bs.toast', () => {
            toastEl.remove();
        });
    }
    
    // Inicia a conex√£o WebSocket
    connectWebSocket();
    
    // Limpa conex√£o ao sair da p√°gina
    window.addEventListener('beforeunload', function() {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.close();
        }
    });
    
});
</script>
{% endblock %}